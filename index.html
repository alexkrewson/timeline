<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Infinite Timeline</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#0d0d0d; }
    canvas { display:block; cursor:grab; }
    canvas:active { cursor:grabbing; }
  </style>
</head>
<body>
<canvas></canvas>

<script>
  const canvas = document.querySelector('canvas');
  const ctx = canvas.getContext('2d');

  const BIG_BANG = -13.8e9;
  const NOW_YEAR = 2025;
  const NOW = 0;  // years from now
  let viewCenter;
  let scale;  // pixels per year
  let isDragging = false;
  let startX = 0;
  let startViewCenter = 0;
  let initial = true;
  let needsRedraw = false;

  const resize = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if (initial) {
      viewCenter = (BIG_BANG + NOW) / 2;
      scale = canvas.width / (NOW - BIG_BANG);
      initial = false;
    }
    clampView();
    requestRedraw();
  };
  window.addEventListener('resize', resize);
  resize();

  // Panning
  canvas.onmousedown = e => {
    if (e.button !== 0) return;
    isDragging = true;
    startX = e.clientX;
    startViewCenter = viewCenter;
    e.preventDefault();
  };

  canvas.onmousemove = e => {
    if (isDragging) {
      const delta = e.clientX - startX;
      viewCenter = startViewCenter - delta / scale;
      clampView();
      requestRedraw();
    }
  };

  canvas.onmouseup = canvas.onmouseleave = () => isDragging = false;
  canvas.oncontextmenu = e => e.preventDefault();

  // Wheel: Ctrl+wheel = zoom; wheel alone = pan
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    e.stopPropagation();

    if (e.ctrlKey) {
      // Zoom
      const delta = e.deltaY;
      const exp = Math.abs(delta) / 100;
      const baseFactor = Math.pow(1.1, exp);
      const zoomFactor = delta > 0 ? 1 / baseFactor : baseFactor;

      const oldScale = scale;
      scale *= zoomFactor;

      const mouseX = e.clientX;
      const mouseWorld = viewCenter + (mouseX - canvas.width / 2) / oldScale;
      viewCenter = mouseWorld - (mouseX - canvas.width / 2) / scale;
    } else {
      // Pan: scroll up = forward (right), down = backward (left)
      const panDelta = e.deltaY * -0.3;  // adjust speed
      viewCenter += panDelta / scale;
    }

    clampView();
    requestRedraw();
  }, { passive: false });

  // Keyboard shortcuts
  document.addEventListener('keydown', e => {
    if (e.ctrlKey) {
      if (e.key === 'End') {
        e.preventDefault();
        scale = canvas.width / 10;  // screen spans 10 years at max zoom
        viewCenter = NOW - (canvas.width / 2) / scale;
        requestRedraw();
      } else if (e.key === 'Home') {
        e.preventDefault();
        const fullRange = -BIG_BANG;
        scale = canvas.width / fullRange;
        viewCenter = NOW - (canvas.width / 2) / scale;
        requestRedraw();
      }
    }
  });

  function clampView() {
    const fullRange = -BIG_BANG;
    const minScale = canvas.width / fullRange;

    // Max scale: screen spans 10 years (ticks every 1 year ~ width/10 px)
    const maxScale = canvas.width / 10;

    scale = Math.max(minScale, Math.min(maxScale, scale));

    const halfWidth = canvas.width / 2 / scale;
    if (viewCenter - halfWidth < BIG_BANG) {
      viewCenter = BIG_BANG + halfWidth;
    }
    if (viewCenter + halfWidth > NOW) {
      viewCenter = NOW - halfWidth;
    }
  }

  function formatTime(t) {
    const year = Math.floor(NOW_YEAR + t);
    if (Math.abs(t) >= 1e9) return (Math.abs(t) / 1e9).toFixed(1) + ' Bya';
    if (Math.abs(t) >= 1e6) return (Math.abs(t) / 1e6).toFixed(0) + ' Mya';
    if (Math.abs(t) >= 1e3) return (Math.abs(t) / 1e3).toFixed(0) + ' kya';
    return year > 0 ? year + ' AD' : (1 - year) + ' BCE';
  }

  function niceStep(target) {
    if (target === 0) return 1;
    const exp = Math.floor(Math.log10(target));
    const frac = target / Math.pow(10, exp);
    let step;
    if (frac < 1.5) step = 1;
    else if (frac < 3) step = 2;
    else if (frac < 7) step = 5;
    else step = 10;
    return step * Math.pow(10, exp);
  }

  function requestRedraw() {
    if (!needsRedraw) {
      needsRedraw = true;
      requestAnimationFrame(draw);
    }
  }

  function draw() {
    needsRedraw = false;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const barHeight = 60;
    const barY = canvas.height / 2 - barHeight / 2;

    ctx.fillStyle = '#333333';
    ctx.fillRect(0, barY, canvas.width, barHeight);
    ctx.strokeStyle = '#444444';
    ctx.lineWidth = 2;
    ctx.strokeRect(0, barY, canvas.width, barHeight);

    const yearsPerPixel = 1 / scale;
    const leftTime = viewCenter - (canvas.width / 2) / scale;
    const rightTime = viewCenter + (canvas.width / 2) / scale;

    let timeStep = niceStep(yearsPerPixel * 80);

    // Force min timeStep = 1 (no sub-year at finest)
    if (timeStep < 1) timeStep = 1;

    const isDense = timeStep < 10;  // rotate if dense (small steps)

    let startT = Math.ceil(leftTime / timeStep) * timeStep;

    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    let stagger = 0;
    let lastScreenX = -Infinity;

    for (let t = startT; t <= rightTime; t += timeStep) {
      const screenX = canvas.width / 2 + (t - viewCenter) * scale;

      // Black tick
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(screenX, barY);
      ctx.lineTo(screenX, barY + barHeight);
      ctx.stroke();

      // Label only if enough space (min 60px)
      if (screenX - lastScreenX >= 60) {
        ctx.save();
        ctx.translate(screenX, barY - 10 - stagger * 15);
        if (isDense) ctx.rotate(-Math.PI / 4);
        ctx.fillStyle = '#ffffff';
        ctx.fillText(formatTime(t), 0, 0);
        ctx.restore();
        lastScreenX = screenX;
        stagger = (stagger + 1) % 2;
      }
    }
  }

</script>
</body>
</html>